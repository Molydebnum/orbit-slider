/*! Path Orbit Slider with GSAP v1.0.0 | MIT License | (c) 2026 Molydebnum */

function createorbitSlider(root,{sliderHeight = "400px",orbitItemWidth = "200px",visibleCount = 3,zIndexMode = "front",alignOrigin = { x: 0.5, y: 0.5 },pathTop = "0px",overflowBuffer = 10,pathWidth = null,pathFront = false,pathDirection = "normal",direction = "left",autoRotate = true,autoPlay = true,autoMode = "linear",autoSpeed = 50,stepCount = 1,stepDuration = 0.6,stepDelay = 1.2,loop = true,pauseOnHover = false,draggable = true,dragSpeed = 0.0015,responsive = null,} = {}) {const orbits = gsap.utils.toArray(root.querySelectorAll(".orbit"));const orbitPath = root.querySelector(".orbitPath");const orbitRoad =root.querySelector("#orbitRoad") || root.querySelector(".orbitRoad");const calculatedWidth = pathWidth? pathWidth: 100 + overflowBuffer * 2 + "%";const calculatedLeft = overflowBuffer * -1 + "%";if (orbitRoad) {Object.assign(orbitRoad.style, {position: "absolute",top: pathTop,left: calculatedLeft,width: calculatedWidth,pointerEvents: "none",zIndex: pathFront ? 10000000 : 0,});}orbits.forEach((el) => {el.style.width = orbitItemWidth;el.style.position = "absolute";});root.style.height = sliderHeight;root.style.width = "100%";root.style.overflow = "hidden";root.style.position = "relative";root.style.willChange = "transform";root.classList.add("orbitSliderTheme");let STEP = 1 / visibleCount;const START_POS = 0.15;let DIR = direction === "right" ? 1 : -1;let loopRange = orbits.length * STEP;const bases = orbits.map((_, i) => START_POS + i * STEP);function getPathPosition(p) {return pathDirection === "reverse" ? 1 - p : p;}let resolvedAutoRotate =autoRotate === false ? false : pathDirection === "reverse" ? 180 : true;let isDragging = false;let isHovering = false;let prevX = 0;let moved = false;let dragDistance = 0;const proxy = { offset: 0 };let autoPlayTween;function calcZIndex(p) {const base = 1000;switch (zIndexMode) {case "front":return base + Math.round(p * 100);case "back":return base + Math.round((1 - p) * 100);case "center":return base + Math.round((1 - Math.abs(p - 0.5) * 2) * 100);default:return base;}}const userOpts = arguments[1] || {};let defaultOpts = { ...userOpts };let currentOpts = { ...userOpts };let dragReleaseLock = false;function applyResponsive() {if (!responsive ||typeof responsive !== "object" ||isDragging ||dragReleaseLock)return;const w = window.innerWidth;const oldLoopRange = loopRange;currentOpts = { ...defaultOpts };const bps = Object.keys(responsive).map(Number).sort((a, b) => a - b);for (let bp of bps) {if (w <= bp) {Object.assign(currentOpts, responsive[bp]);break;}}({sliderHeight,orbitItemWidth,visibleCount,zIndexMode,alignOrigin,pathTop,overflowBuffer,pathWidth,pathFront,pathDirection,direction,autoRotate,autoPlay,autoMode,autoSpeed,stepCount,stepDuration,stepDelay,loop,pauseOnHover,draggable,dragSpeed,} = {...{sliderHeight,orbitItemWidth,visibleCount,zIndexMode,alignOrigin,pathTop,overflowBuffer,pathWidth,pathFront,pathDirection,direction,autoRotate,autoPlay,autoMode,autoSpeed,stepCount,stepDuration,stepDelay,loop,pauseOnHover,draggable,dragSpeed,},...currentOpts,});root.style.height = sliderHeight;const calculatedWidth = pathWidth || 100 + overflowBuffer * 2 + "%";const calculatedLeft = overflowBuffer * -1 + "%";if (orbitRoad) {Object.assign(orbitRoad.style, {position: "absolute",top: pathTop,left: calculatedLeft,width: calculatedWidth,zIndex: pathFront ? 10000 : 0,pointerEvents: "none",});}orbits.forEach((el) => (el.style.width = orbitItemWidth));if (orbitRoad) {orbitRoad.style.zIndex = currentOpts.pathFront ? 10000000 : 0;}STEP = 1 / Math.max(1, visibleCount || 1);DIR = direction === "right" ? 1 : -1;const newLoopRange = orbits.length * STEP;if (oldLoopRange !== 0) {proxy.offset = (proxy.offset / oldLoopRange) * newLoopRange;}loopRange = newLoopRange;bases.length = 0;orbits.forEach((_, i) => bases.push(START_POS + i * STEP));resolvedAutoRotate =autoRotate === false ? false : pathDirection === "reverse" ? 180 : true;if (autoPlay) {resumeAutoPlay();}}function updatePositions() {if (loop) {proxy.offset = gsap.utils.wrap(0, loopRange, proxy.offset);} else {const minOffset = -bases[0];const maxOffset = 1 - bases[bases.length - 1];proxy.offset = gsap.utils.clamp(Math.min(minOffset, maxOffset),Math.max(minOffset, maxOffset),proxy.offset);}orbits.forEach((el, i) => {let p = bases[i] + proxy.offset;if (loop) p = gsap.utils.wrap(0, loopRange, p);const isVisible = p >= -0.1 && p <= 1.1;if (isVisible) {const mp = getPathPosition(p);gsap.set(el, {autoAlpha: 1,zIndex: calcZIndex(mp),motionPath: {path: orbitPath,align: orbitPath,alignOrigin: [alignOrigin.x, alignOrigin.y],autoRotate: resolvedAutoRotate,start: mp,end: mp,},});} else {gsap.set(el, { autoAlpha: 0 });}});}function startAutoPlay() {if (!autoPlay || isDragging || isHovering) return;if (autoPlayTween) autoPlayTween.kill();if (!loop) {const isAtEnd =(DIR === -1 && proxy.offset <= 1 - bases[bases.length - 1]) ||(DIR === 1 && proxy.offset >= 1 - bases[0]);if (isAtEnd) return;}if (autoMode === "linear") {autoPlayTween = gsap.to(proxy, {offset: `+=${loopRange * DIR}`,duration: autoSpeed,ease: "none",repeat: loop ? -1 : 0,onUpdate: updatePositions,});return;}autoPlayTween = gsap.timeline({onComplete: () => {if (!isDragging && !isHovering) startAutoPlay();},});autoPlayTween.to(proxy, {offset: `+=${STEP * stepCount * DIR}`,duration: stepDuration,ease: "power2.inOut",onUpdate: updatePositions,});autoPlayTween.to({}, { duration: stepDelay });}function pauseAutoPlay() {if (autoPlayTween) autoPlayTween.pause();}function resumeAutoPlay() {if (autoPlayTween) autoPlayTween.kill();startAutoPlay();}if (draggable) {orbits.forEach((orbit) => {orbit.setAttribute("draggable", "false");orbit.style.webkitTouchCallout = "none";orbit.querySelectorAll("img, a , p , span").forEach((el) => {el.setAttribute("draggable", "false");el.style.userSelect = "none";el.style.webkitUserDrag = "none";el.style.webkitTouchCallout = "none";});});root.style.cursor = "grab";root.style.touchAction = "none";const onDown = (e) => {if (e.pointerType === "mouse" && e.button !== 0) return;isDragging = true;root.style.cursor = "grabbing";prevX = e.clientX;moved = false;dragDistance = 0;pauseAutoPlay();};const onMove = (e) => {if (!isDragging) return;const delta = e.clientX - prevX;prevX = e.clientX;dragDistance += Math.abs(delta);if (dragDistance > 5) moved = true;proxy.offset += delta * dragSpeed;updatePositions();if (e.cancelable) e.preventDefault();};const onUp = () => {if (!isDragging) return;dragReleaseLock = true;isDragging = false;root.style.cursor = "grab";if (!isHovering) resumeAutoPlay();requestAnimationFrame(() => (dragReleaseLock = false));};root.addEventListener("pointerdown", onDown);window.addEventListener("pointermove", onMove, { passive: false });window.addEventListener("pointerup", onUp);window.addEventListener("pointercancel", onUp);orbits.forEach((el) => {el.addEventListener("click", (e) => {if (moved) {e.preventDefault();e.stopPropagation();}});});}if (pauseOnHover) {root.addEventListener("mouseenter", () => {isHovering = true;pauseAutoPlay();});root.addEventListener("mouseleave", () => {isHovering = false;if (!isDragging) resumeAutoPlay();});}if ("IntersectionObserver" in window) {const observer = new IntersectionObserver((entries) => {entries.forEach((entry) => {if (entry.isIntersecting) {if (autoPlay) resumeAutoPlay();} else {pauseAutoPlay();}});},{ threshold: 0.1 });observer.observe(root);}let resizeTimer;applyResponsive();updatePositions();startAutoPlay();window.addEventListener("resize", () => {clearTimeout(resizeTimer);resizeTimer = setTimeout(() => {applyResponsive();updatePositions();}, 200);});
}